---
layout: userguide
title: User Guide
---
<h4>Using JavaScript objects, methods and operators</h4>
<p>
	In general, you can use JavaScript objects in your Java/ST-JS code in exactly the same way as you would in
	JavaScript. You can access fields using the familiar <span class="InlineCode">object.propery</span> notation, and
	invoke methods using <span class="InlineCode">object.method(arg)</span> notation. There are however a few JavaScript
	specific idioms and constructs that cannot be translated as-is into Java that you need to know about.
</p>
<p>
	You will find that most methods that cause ST-JS to translate the source Java code into JavaScript code
	that doesn't look exactly like the source are prefixed with the <span class="InlineCode">$</span> character so that
	they are easily identifiable (eg: <span class="InlineCode">$map</span>, <span class="InlineCode">$array</span>,
	<span class="InlineCode">$get</span>, <span class="InlineCode">$put</span>, etc...)
</p>
<h5>Arrays</h5>
<p>
	In ST-JS the JavaScript <span class="InlineCode">Array</span> type is mapped to the
	<span class="InlineCode">org.stjs.javascript.Array</span> class. Some array related constructs are used in a
	different way in Java and Javascript. The list below lists all of the important cases:
</p>

<div class="grid_6 alpha">
<pre class="code prettyprint language-java">
// Java
// [1] Constructor with new
new Array&lt;SomeType&gt;()
new Array&lt;SomeType&gt;(length)
new Array&lt;SomeType&gt;(el1, el2, el3)

// [2] Constructor without new
Array()
Array(length)
Array(el1, el2, el3)

// [3] Array literal
$array(el1, el2, el3)

// [4] Read access
arr.$get(index)

// [5] Write access
arr.$set(index, value)

// [6] Read length
arr.$length()

// [7] Set length
arr.$length(newLength)

// [8] Iteration with for-in
for(String i : arr){
	...
}

// [9] Iteration with forEach
arr.$forEach(val -> ...)
arr.$forEach((val, i, a) -> ...)
</pre>
</div>
<div class="grid_6 omega">
<pre class="code prettyprint language-javascript">
// JavaScript
// [1] Constructor with new
new Array()
new Array(length)
new Array(el1, el2, el3)

// [2] Constructor without new
Array()
Array(length)
Array(el1, el2, el3)

// [3] Array literal (in JSCollections)
[el1, el2, el3]

// [4] Read access
arr[index]

// [5] Write access
arr[index] = value

// [6] Read length
arr.length

// [7] Set length
arr.length = newLength

// [8] Iteration with for-in
for(var i in arr){
	if (arr.hasOwnProperty(i)) { ... }
}

// [9] Iteration with forEach
arr.forEach(function(val){ ... })
arr.forEach(function(val, i, a){ ... })
</pre>
</div>
<div class="clear"></div>
<p>
	All the methods not shown in the snippet above can be called in exactly the same way as you would in JavaScript.
</p>
<p>
	ST-JS also bundles a full JavaDoc of the <span class="InlineCode">Array</span> API. If your IDE is setup correctly
	you should be able to automatically see the documentation for each method right as you type it.
</p>
<ul>
	<li>
		[1] No differences between Java and JavaScript.
	</li>
	<li>
		[2] No differences between Java and JavaScript. The <span class="InlineCode">Array</span> method is a static
		member of the <span class="InlineCode">org.stjs.javascript.JSGlobal</span> class.
	</li>
	<li>
		[3] <span class="InlineCode">$array()</span> is a static function declared in the class
		<span class="InlineCode">org.stjs.javascript.JSCollections</span>. ST-JS cannot use native Java array literals
		because they yield the wrong data type (<span class="InlineCode">SomeType[]</span> instead of
		<span class="InlineCode">Array&lt;Sometype&gt;</span>.
	</li>
	<li>
		[4],[5] The java native arrays are native types that don't define any methods, and are therefore not suitable to
		mirror the very rich JavaScript arrays. Unfortunately, the <span class="InlineCode">[]</span> notation can
		ony be used with native arrays in Java. The <span class="InlineCode">$get()</span> method is the ST-JS way of
		working around this impedance mismatch between two languages.
	</li>
	<li>
		[6],[7] In JavaScript arrays, setting the length property of arrays may have side-effects like truncating the
		array. In Java, it is unfortunately impossible to apply side effects when a field is set directly. It is
		however possible to do so if the field is set through an accessor method instead of directly. One of the goals
		of ST-JS was to be able to run short snippets of client-side code directly on the server in order to avoid code
		duplication. The <span class="InlineCode">$length()</span> methods are the ST-JS way of meeting all of these
		constraints at the same time.
	</li>
	<li>
		[8] The Java form of the for-in loop makes one of the quirks of JavaScript very apparent: The for-in loop on
		arrays iterates on the indices rather than on the values, it returns all the indices as Strings, and it also
		includes all enumerable prototype properties in the iteration. While this behavior makes sense when considering
		arrays as Objects in JavaScript, it is pretty confusing and unexpected. ST-JS solves this problem by making it
		clear that the iteration type are Strings, and by making sure that the iteration only happens on array indices
		and not on any other prototype properties.
	</li>
	<li>
		[9] In Java 8 the <span class="InlineCode">Iterable</span> interface which is implemented by the
		<span class="InlineCode">Array</span> class introduced a new method with a default implementation:
		<span class="InlineCode">forEach</span>. Unfortunately, the <span class="InlineCode">Array</span> already
		contained a <span class="InlineCode">forEach</span> method since its very first version, back before Java 8
		became available, but with a very slightly different signature. Unfortunately, the two signatures are considered
		different by the Java compiler but are so similar that they are ambiguous when using lambdas or method
		references. This means that lambdas and method references couldn't be used without ugly type casting, partially
		defeating their purpose of improving code readability. The <span class="InlineCode">$forEach()</span> methods
		solve this problem.
	</li>
</ul>

<h5>Associative Arrays / Maps</h5>
<p>
	ST-JS provides a simple Map-like functionality by exposing bare JavaScript objects as key-value stores. The
	advantage of this approach is that the generated JavaScript code can be executed directly without depending on
	a specific library. Given the static nature of Java, the natural and dynamic
	<span class="InlineCode">object["propertyName"]</span> notation cannot be used directly. The
	<span class="InlineCode">org.stjs.javascript.Map</span> class can be used instead.
</p>

<div class="grid_6 alpha">
<pre class="code prettyprint language-java">
// Java
// [1] Construction with Object literal
Map&lt;String, SomeType&gt; map = $map()
Map&lt;String, SomeType&gt; map = $map("k1", v1, "k2", v2)

// [2] Reading
map.$get(key)

// [3] Writing
map.$put(key, value)

// [4] Deleting
map.$delete(key)

// [5] Iteration with for-in
for(String key : map){
	...
}
</pre>
</div>
<div class="grid_6 omega">
<pre class="code prettyprint language-javascript">
// JavaScript
// [1] Construction with Object literal
var map = {}
var map = {"k1": v1, "k2": v2}

// [2] Reading
map[key]

// [3] Writing
map[key] = value;

// [4] Deleting
delete map[key]

// [5] Iteration with for-in
for(var key in map){
	if (map.hasOwnProperty(key)) { ... }
}
</pre>
</div>
<div class="clear"></div>
<ul>
	<li>
		[1] <span class="InlineCode">$map()</span> is a static function declared in the class
		<span class="InlineCode">org.stjs.javascript.JSCollections</span>. Just like in Javascript,
		you can only use string literals as keys. Attempting to use anything else results in a compile
		time error. Values however may be any kind of expression.
	</li>
	<li>
		[2], [3], [4] Unfortunately, the <span class="InlineCode">[]</span> notation can ony be used with native arrays
		in Java. On top of that, the JavaScript <span class="InlineCode">$delete()</span> keyword has no equivalent at
		all in Java. The <span class="InlineCode">$get()</span> and <span class="InlineCode">$put()</span> methods is
		the ST-JS way of working around this impedance mismatch between two languages.
	</li>
	<li>
		[5] No differences between Java and JavaScript
	</li>
</ul>

<h5>undefined</h5>
<p>
	The <span class="InlineCode">undefined</span> value is a pure JavaScript concept that has no equivalent in Java.
	ST-JS simply treats <span class="InlineCode">undefined</span> as <span class="InlineCode">null</span>. In our
	experience, this simple equivalence is enough to handle undefined correctly. Below are some examples of expressions
	that are often used when dealing with <span class="InlineCode">undefined</span> in different cases:
</p>
<div class="grid_6 alpha">
<pre class="code prettyprint language-java">
// Java
// [1] Checking for equality
myvar == null

// [2] Checking for type
typeof(myvar) == "undefined"

// [3] Assignment
myvar = undefined
</pre>
</div>
<div class="grid_6 omega">
<pre class="code prettyprint language-javascript">
// JavaScript
// [1] Checking for equality
myvar == null

// [2] Checking for type
(typeof myvar) == "undefined"

// [3] Assignment
myvar = undefined
</pre>
</div>
<div class="clear"></div>
<ul>
	<li>
		[1] No differences between Java and JavaScript. Just like in JavaScript, it makes to sense to write
		<span class="InlineCode">myvar == undefined</span> since nothing is equal to
		<span class="InlineCode">undefined</span>, including <span class="InlineCode">undefined</span> itself.
	</li>
	<li>
		[2] Almost no differences between Java and JavaScript. The only difference is the placement of the parenthesis.
		The <span class="InlineCode">typeof</span> function is a static member of the
		<span class="InlineCode">org.stjs.javascript.JSGlobal</span> class.
	</li>
	<li>
		[3] No differences between Java and JavaScript. The <span class="InlineCode">undefined</span> value is a static
		member of the <span class="InlineCode">org.stjs.javascript.JSGlobal</span> class.
	</li>
</ul>


<h5>The == and === operators</h5>
<p>
	The Java <span class="InlineCode">==</span> operator is translated directly to the JavaScript
	<span class="InlineCode">==</span> operator.
</p>
<p>
	It might seem at first that the <span class="InlineCode">===</span> operator is a more faithful translation of the
	intent expressed in Java source, but given that Java lacks the concept of <span class="InlineCode">undefined</span>
	and that <span class="InlineCode">null !== undefined</span> in JavaScript, using <span class="InlineCode">===</span>
	would leave us with no simple way to guard against <span class="InlineCode">undefined</span> values.
	<span class="InlineCode">typeof</span> could work, but the condition is rather cumbersome to use and needs to be
	combined with a check against <span class="InlineCode">null</span> anyway.
</p>
<p>
	On top of that, the fact that ST-JS code is type checked before being translated to JavaScript pretty much
	guarantees that <span class="InlineCode">===</span> and <span class="InlineCode">==</span> are equivalent in the
	vast majority of cases. There are a few cases where they aren't (such as when the ST-JS code is being called
	incorrectly by external JavaScript code), but we have decided to let the users handle those rare cases manually to
	gain in clarity in the majority of common cases.
</p>

<h5>Constructor, prototype, Class and referencing properties by name</h5>
<p>
	Every JavaScript object contains the special <span class="InlineCode">constructor</span> and
	<span class="InlineCode">prototype</span> properties. Those properties are not available in the Java
	<span class="InlineCode">Object</span> definition, but ST-JS provides different ways to access them.
</p>
<p>
	The various properties of JavaScript objects can also always be accessed directly by name. ST-JS also provides
	different ways to expose this functionality in Java code.
</p>
<div class="grid_6 alpha">
<pre class="code prettyprint language-java">
// Java
// [1] Get a property by name
$get(somevar, "property")

// [2] Set a property by name
$put(somevar, "property", value);

// [3] Iterating over all properties
for(String propName : $properties(obj)){
	...
}

// [4] Referencing a prototype
$prototype(obj)

// [5] Referencing a constructor
$constructor(obj)
obj.getClass()
MyType.class
</pre>
</div>
<div class="grid_6 omega">
<pre class="code prettyprint language-javascript">
// JavaScript
// [1] Get a property by name
somevar["property"]

// [2] Set a property by name
somevar["property"] = value;

// [3] Iterating over all properties
for(var propName in obj){
	if (obj.hasOwnProperty(propName)) { ... }
}

// [4] Referencing a prototype
obj.prototype

// [5] Referencing a constructor
obj.constructor
obj.getClass()
MyType
</pre>
</div>
<div class="clear"></div>
<ul>
	<li>
		[1],[2] The <span class="InlineCode">$get()</span> and <span class="InlineCode">$set()</span> methods are
		static members of the <span class="InlineCode">org.stjs.javascript.JSObjectAdapter</span> class. They work
		in exactly the same way as their <span class="InlineCode">Map</span> equivalent, but operate on any object.
	</li>
	<li>
		[3] The <span class="InlineCode">$properties()</span> method is a static member of the
		<span class="InlineCode">org.stjs.javascript.JSObjectAdapter</span> class. It basically just casts any object
		to a generic STJS <span class="InlineCode">Map&lt;String, Object&gt;</span> from which you can read properties
		using the <span class="InlineCode">Map</span> API.
	</li>
	<li>
		[4] The <span class="InlineCode">$prototype()</span> method is a static member of the
		<span class="InlineCode">org.stjs.javascript.JSObjectAdapter</span> class.
	</li>
	<li>
		[5] The <span class="InlineCode">$constructor()</span> method is a static member of the
		<span class="InlineCode">org.stjs.javascript.JSObjectAdapter</span> class.
		<span class="InlineCode">$constructor()</span>, <span class="InlineCode">getClass()</span> and class literals
		are equivalent in terms of what value is actually returned in JavaScript, but only
		<span class="InlineCode">$constructor()</span> is really type safe. In some cases, it might still be preferable
		to use the class literal or<span class="InlineCode">getClass()</span> method to better convey intent in your
		code, but if you do so please keep in mind that <span class="InlineCode">java.lang.Class</span> is not currently
		mapped my ST-JS and that any methods you call on this class will fail at runtime.
	</li>
</ul>

<h5>The || operator</h5>
<p>
	In javascript, the <span class="InlineCode">||</span> operator can be used to return the first truthy value of a
	list. In Java, that same operator can only be applied to boolean values and will always return a boolean. In most
	cases that is enough, but in some cases the JavaScript behavior is desirable. In those cases, you can use the
	techniques below:
</p>

<div class="grid_6 alpha">
<pre class="code prettyprint language-java">
// Java
$or(val1, val2)
$or(val1, val2, val3)
</pre>
</div>
<div class="grid_6 omega">
<pre class="code prettyprint language-javascript">
// JavaScript
val1 || val2
val1 || val2 || val3
</pre>
</div>
<div class="clear"></div>
<p>
	The <span class="InlineCode">$or()</span> method is a static member of the
	<span class="InlineCode">org.stjs.javascript.JSObjectAdapter</span> class.
</p>

<h5>Handling un-translatable cases</h5>
<p>
	In some rare cases, the JavaScript code cannot be expressed cleanly (or at all) using the ST-JS API. For these
	very special cases, you can use <span class="InlineCode">org.stjs.javascript.JSObjectAdapter.$js()</span>. This
	method only accepts string literals and outputs the content of the string directly inside the generated
	JavaScript code. The JS code in the string literal must also be a full expression, and will be surrounded by
	parenthesis in the generated code.
</p>
<div class="grid_6 alpha">
<pre class="code prettyprint language-java">
// Java
Array&lt;String&gt; list =
	$js("Array.prototype.slice.call(arguments, 0)")
</pre>
</div>
<div class="grid_6 omega">
<pre class="code prettyprint language-javascript">
// JavaScript
var list =
	(Array.prototype.slice.call(arguments, 0))
</pre>
</div>
<div class="clear"></div>
<p>
	Please use <span class="InlineCode">$js()</span> with great care as it is not type safe. It is also not verified to
	be syntactically valid and, if used incorrectly, could cause the generated code to be un-parseable.
</p>